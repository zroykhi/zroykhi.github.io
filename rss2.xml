<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Zhi ZHOU&#39;s blog</title>
    <link>http://zhizhou.site/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Moi? Ça va</description>
    <pubDate>Thu, 02 Aug 2018 13:13:34 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Thinkphp5教程三:入口文件</title>
      <link>http://zhizhou.site/2018/08/02/Thinkphp5%E6%95%99%E7%A8%8B%E4%B8%89-%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6/</link>
      <guid>http://zhizhou.site/2018/08/02/Thinkphp5%E6%95%99%E7%A8%8B%E4%B8%89-%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6/</guid>
      <pubDate>Thu, 02 Aug 2018 13:05:51 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;最近在学thinkPHP, 但是官网给的教程十分简陋, 惜字如金, 很多没有解释清楚. 所以自己整理了一些笔记, 供参考. 转载请联系.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;开始之前, 可以首先将application文件夹名字修改为app,
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>最近在学thinkPHP, 但是官网给的教程十分简陋, 惜字如金, 很多没有解释清楚. 所以自己整理了一些笔记, 供参考. 转载请联系.</p></blockquote><p>开始之前, 可以首先将application文件夹名字修改为app, 然后修改public/index.php入口文件中的<code>define(&#39;APP_PATH&#39;, __DIR__ . &#39;/../application/&#39;);</code> 变为<code>define(&#39;APP_PATH&#39;, __DIR__ . &#39;/../app/&#39;);</code>, 这样之后的代码在逻辑上可能更好理解. 我项目的主目录是ThinkPHP/, 如果你的项目不是这个名字, 需要自行修改保证url能正常访问.</p><h1 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h1><p>单入口文件: 应用程序的所有http请求都由某文件接收并由这个文件转发到功能代码中. thinkPHP框架中所有的请求都经过public/index.php.</p><p>单入口文件优势:</p><ul><li>安全检测</li><li>请求过滤</li></ul><p><code>public/index.php</code>文件中必须加载框架引导文件<code>start.php</code>, 该文件为我们处理安全过滤.可以修改app/index/controller/Index.php文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace app\index\controller;</span><br><span class="line"></span><br><span class="line">class index</span><br><span class="line">&#123;</span><br><span class="line">  public function index()</span><br><span class="line">  &#123;</span><br><span class="line">    dump(config());// print all the configs</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="隐藏入口文件"><a href="#隐藏入口文件" class="headerlink" title="隐藏入口文件"></a>隐藏入口文件</h1><p>方法:</p><ul><li>将websever的根目录设置为项目的public/文件夹</li><li>取消注释<code>httpd.conf</code>文件(Ubuntu中在/opt/lampp/etc/下)里的<code>LoadModule rewrite_module modules/mod_rewrite.so</code></li><li>将该文件中的<directory “root_dir_of_your_web_server”="">下的<code>AllowOverride None改为AllowOverride All</code></directory></li><li><p>同时保证网站目录public/.htaccess文件中内容为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line">  Options +FollowSymlinks -Multiviews</span><br><span class="line">  RewriteEngine On</span><br><span class="line"></span><br><span class="line">  RewriteCond %&#123;REQUEST_FILENAME&#125; !-d</span><br><span class="line">  RewriteCond %&#123;REQUEST_FILENAME&#125; !-f</span><br><span class="line">  RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure></li><li><p>重启Apache</p></li></ul><p>注释: <code>RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]</code>是指将所有请求<code>^(.*)$</code>放到index.php/后面的<code>$1</code>这里, 所以保证我们能正常访问.</p><h1 id="入口文件的绑定"><a href="#入口文件的绑定" class="headerlink" title="入口文件的绑定"></a>入口文件的绑定</h1><p>在入口文件index.php添加:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(&apos;BIND_MODULE&apos;, &apos;demo&apos;);</span><br></pre></td></tr></table></figure></p><p>则url访问demo模块下Index控制器的index方法需要输入: <a href="http://localhost/ThinkPHP/public/Index/index" target="_blank" rel="noopener">http://localhost/ThinkPHP/public/Index/index</a></p><p>若是<code>define(&#39;BIND_MODULE&#39;, &#39;demo/index&#39;);</code>, 则url访问demo模块下Index控制器的index方法需要输入:<br><a href="http://localhost/ThinkPHP/public/index" target="_blank" rel="noopener">http://localhost/ThinkPHP/public/index</a><br>总之要保证define里面参数加上url的参数最终得到: 模块/控制器/方法 的形式, 才可以正确访问, 只有小项目的时候需要设置入口文件绑定, 大项目一般不用设置.</p><p>假设我们的项目需要给第三方提供接口, 这时我们不希望第三方还访问经过public/index.php, 我们可以建立public/api.php, 写入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">define(&apos;APP_PATH&apos;, __DIR__ . &apos;/../application/&apos;);</span><br><span class="line">define(&apos;CONF_PATH&apos;, __DIR__ . &apos;/../conf/&apos;);</span><br><span class="line">define(&apos;BIND_MODULE&apos;, &apos;api&apos;);</span><br><span class="line">require __DIR__ . &apos;/../thinkphp/start.php&apos;;</span><br></pre></td></tr></table></figure></p><p>此时我们访问: <a href="http://localhost/ThinkPHP/public/api.php" target="_blank" rel="noopener">http://localhost/ThinkPHP/public/api.php</a>, 则只能访问到api这个模块了.</p><p>或者使用thinkPHP提供的另一个功能. 在conf/config.php文件中添加配置: <code>‘auto_bind_module’  =&gt; true</code>, 这时系统会根据url里面含有的php文件名自动访问对应的同名模块. 这时假设我们url输入: <a href="http://localhost/ThinkPHP/public/api.php/index/demo" target="_blank" rel="noopener">http://localhost/ThinkPHP/public/api.php/index/demo</a><br>即可直接访问api模块下的index控制器的demo方法.</p><p>需要注意的是, 通过设置<code>auto_bind_module</code>绑定的方法是可以访问其他模块的, 而通过define方式绑定的入口若没有该模块则直接报错.</p>]]></content:encoded>
      
      <comments>http://zhizhou.site/2018/08/02/Thinkphp5%E6%95%99%E7%A8%8B%E4%B8%89-%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Thinkphp5教程二:系统环境配置和使用</title>
      <link>http://zhizhou.site/2018/08/02/Thinkphp5%E6%95%99%E7%A8%8B%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/</link>
      <guid>http://zhizhou.site/2018/08/02/Thinkphp5%E6%95%99%E7%A8%8B%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/</guid>
      <pubDate>Thu, 02 Aug 2018 12:50:52 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;最近在学thinkPHP, 但是官网给的教程十分简陋, 惜字如金, 很多没有解释清楚. 所以自己整理了一些笔记, 供参考. 转载请联系.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;开始之前, 可以首先将application文件夹名字修改为app,
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>最近在学thinkPHP, 但是官网给的教程十分简陋, 惜字如金, 很多没有解释清楚. 所以自己整理了一些笔记, 供参考. 转载请联系.</p></blockquote><p>开始之前, 可以首先将application文件夹名字修改为app, 然后修改public/index.php入口文件中的<code>define(&#39;APP_PATH&#39;, __DIR__ . &#39;/../application/&#39;);</code> 变为<code>define(&#39;APP_PATH&#39;, __DIR__ . &#39;/../app/&#39;);</code>, 这样之后的代码在逻辑上可能更好理解. 我项目的主目录是ThinkPHP/, 如果你的项目不是这个名字, 需要自行修改保证url能正常访问.</p><p>首先在项目的根目录下面建立一个.env文件(文件名不可以更改), 在里面直接设置环境参数值. 如: <a href="mailto:email=2222@qq.com" target="_blank" rel="noopener">email=2222@qq.com</a>, 获取该环境变量只需要<code>dump($\_ENV[‘PHP_EMAIL’]);</code><br>如果<code>$\_ENV</code>为空，其原因通常是php的配置文件/opt/lampp/etc/php.ini的配置项为<code>variables_order = &quot;GPCS&quot;</code>。要想让<code>$\_ENV</code>的值不为空，那么<code>variables_order</code>的值应该加上一个大写字母“E”即<code>variables_order = &quot;EGPCS&quot;</code>。然后重启lampp: <code>sudo /opt/lampp/lampp restart</code></p><p>使用<code>$\_ENV</code>时候, 系统会自动在设置的环境变量名前面增加<code>PHP_</code>, 同时将环境变量名变成大写, 所以这时获取某环境变量时记得做相应改变; 为避免这个不方便的地方, 我们可以使用Env类. app/index/controller/Index.php:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace app\index\controller;</span><br><span class="line"></span><br><span class="line">use think\Config;</span><br><span class="line">use think\Env;</span><br><span class="line"></span><br><span class="line">class Index</span><br><span class="line">&#123;</span><br><span class="line">  public function index()</span><br><span class="line">  &#123;</span><br><span class="line">    // dump($_ENV);</span><br><span class="line">    // dump($_ENV[&apos;PHP_EMAIL&apos;]);</span><br><span class="line"></span><br><span class="line">    $res = Env::get(&apos;email&apos;);</span><br><span class="line">    dump($res);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们配合使用场景配置和环境变量设置就可以切换线上线下生产环境的配置. 例子conf/config.php中写:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">use think\Env;</span><br><span class="line">return [</span><br><span class="line">    ‘app_status’  =&gt;  Env::get(‘app_status’, ‘dev’)</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>Env::get()的第二个参数是默认值(当该该参数没有设置时). conf/test.php:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">return [</span><br><span class="line">    ‘app_now_statue’  =&gt; ‘test’</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>conf/dev.php:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">return [</span><br><span class="line">    ‘app_now_statue’  =&gt; ‘dev’</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>Index.php:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace app\index\controller;</span><br><span class="line"></span><br><span class="line">use think\Config;</span><br><span class="line">use think\Env;</span><br><span class="line"></span><br><span class="line">class Index</span><br><span class="line">&#123;</span><br><span class="line">  public function index()</span><br><span class="line">  &#123;</span><br><span class="line">    dump(config());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当我们需要改变环境时候, 只需要将.env文件下的status=test和status=dev之间切换, 即可该变环境. 这样我们做到仅仅修改.env文件, 其他文件都不变, 就可以实现不同环境之间的切换.</p><p>另一个例子, conf/database.php:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">use think\Env;</span><br><span class="line"></span><br><span class="line">    return [</span><br><span class="line">        // 数据库类型</span><br><span class="line">        &apos;type&apos;            =&gt; &apos;mysql&apos;,</span><br><span class="line">        // 数据库连接DSN配置</span><br><span class="line">        &apos;dsn&apos;             =&gt; &apos;&apos;,</span><br><span class="line">        // 服务器地址</span><br><span class="line">        &apos;hostname&apos;        =&gt; &apos;127.0.0.1&apos;,</span><br><span class="line">        // 数据库名</span><br><span class="line">        &apos;database&apos;        =&gt; &apos;&apos;,</span><br><span class="line">        // 数据库用户名</span><br><span class="line">        &apos;username&apos;        =&gt; Env::get(‘database.username’, ‘root’)</span><br><span class="line">        // 数据库密码</span><br><span class="line">        &apos;password&apos;        =&gt; &apos;&apos;,</span><br><span class="line">        // 数据库连接端口</span><br><span class="line">        &apos;hostport&apos;        =&gt; &apos;&apos;,</span><br><span class="line">        // 数据库连接参数</span><br><span class="line">        &apos;params&apos;          =&gt; [],</span><br><span class="line">        // 数据库编码默认采用utf8</span><br><span class="line">        &apos;charset&apos;         =&gt; &apos;utf8&apos;,</span><br><span class="line">        // 数据库表前缀</span><br><span class="line">        &apos;prefix&apos;          =&gt; &apos;&apos;,</span><br><span class="line">        // 数据库调试模式</span><br><span class="line">        &apos;debug&apos;           =&gt; false,</span><br><span class="line">        // 数据库部署方式:0 集中式(单一服务器),1 分布式(主从服务器)</span><br><span class="line">        &apos;deploy&apos;          =&gt; 0,</span><br><span class="line">        // 数据库读写是否分离 主从式有效</span><br><span class="line">        &apos;rw_separate&apos;     =&gt; false,</span><br><span class="line">        // 读写分离后 主服务器数量</span><br><span class="line">        &apos;master_num&apos;      =&gt; 1,</span><br><span class="line">        // 指定从服务器序号</span><br><span class="line">        &apos;slave_no&apos;        =&gt; &apos;&apos;,</span><br><span class="line">        // 是否严格检查字段是否存在</span><br><span class="line">        &apos;fields_strict&apos;   =&gt; true,</span><br><span class="line">        // 数据集返回类型</span><br><span class="line">        &apos;resultset_type&apos;  =&gt; &apos;array&apos;,</span><br><span class="line">        // 自动写入时间戳字段</span><br><span class="line">        &apos;auto_timestamp&apos;  =&gt; false,</span><br><span class="line">        // 时间字段取出后的默认时间格式</span><br><span class="line">        &apos;datetime_format&apos; =&gt; &apos;Y-m-d H:i:s&apos;,</span><br><span class="line">        // 是否需要进行SQL性能分析</span><br><span class="line">        &apos;sql_explain&apos;     =&gt; false,</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure></p><p>.env文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[database]</span><br><span class="line">username=root_env</span><br><span class="line">password=root</span><br></pre></td></tr></table></figure></p><p>修改username变量即可方便地切换环境.</p>]]></content:encoded>
      
      <comments>http://zhizhou.site/2018/08/02/Thinkphp5%E6%95%99%E7%A8%8B%E4%BA%8C-%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Thinkphp5教程一:项目配置</title>
      <link>http://zhizhou.site/2018/08/02/Thinkphp5%E6%95%99%E7%A8%8B%E4%B8%80-%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/</link>
      <guid>http://zhizhou.site/2018/08/02/Thinkphp5%E6%95%99%E7%A8%8B%E4%B8%80-%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/</guid>
      <pubDate>Thu, 02 Aug 2018 12:32:39 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;最近在学thinkPHP, 但是官网给的教程十分简陋, 惜字如金, 很多没有解释清楚. 所以自己整理了一些笔记, 供参考. 转载请联系.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;开始之前, 可以首先将application文件夹名字修改为app,
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>最近在学thinkPHP, 但是官网给的教程十分简陋, 惜字如金, 很多没有解释清楚. 所以自己整理了一些笔记, 供参考. 转载请联系.</p></blockquote><p>开始之前, 可以首先将application文件夹名字修改为app, 然后修改public/index.php入口文件中的<code>define(&#39;APP_PATH&#39;, __DIR__ . &#39;/../application/&#39;);</code> 变为<code>define(&#39;APP_PATH&#39;, __DIR__ . &#39;/../app/&#39;);</code>, 这样之后的代码在逻辑上可能更好理解. 我项目的主目录是ThinkPHP/, 如果你的项目不是这个名字, 需要自行修改保证url能正常访问.</p><h1 id="惯例配置"><a href="#惯例配置" class="headerlink" title="惯例配置"></a>惯例配置</h1><p>在入口文件中定义项目config文件夹.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 定义配置文件目录</span><br><span class="line">define(&apos;CONF_PATH&apos;, __DIR__ . &apos;/../conf/&apos;);</span><br></pre></td></tr></table></figure></p><p>convention.php里面有默认定义, 默认是application文件夹之下的config.php, 然后在app同级文件中建立一个新文件夹conf/, 该文件夹中建立一个config.php文件, 里面的配置对所有的应用起效. 这样的规划对项目后期维护很方便, 因为它的默认配置有很多是不变的。访问: <a href="http://localhost/ThinkPHP/public/index/Index/index" target="_blank" rel="noopener">http://localhost/ThinkPHP/public/index/Index/index</a>  即可查看所有的config.</p><p>application文件夹下的config.php文件配置会覆盖convention文件的配置</p><h1 id="拓展配置"><a href="#拓展配置" class="headerlink" title="拓展配置"></a>拓展配置</h1><p>可以在上面建立的conf文件夹之下建立一个extra文件夹, 里面建立一个email.php, 写入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">return [</span><br><span class="line">  &apos;host&apos; =&gt; &apos;stmp@qq.com&apos;,</span><br><span class="line">  &apos;name&apos; =&gt; &apos;333@qq.com&apos;</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p><p>Index.php控制器中输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace app\index\controller;</span><br><span class="line"></span><br><span class="line">class index&#123;</span><br><span class="line">  public function index()</span><br><span class="line">  &#123;</span><br><span class="line">    dump(config()); // 打印所有配置</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么打印的配置中会多了一项email, 其值为一个数组就是上面我们设置的. 它默认文件名为配置名称, return回来是该名称配置的数组配置值. 我们可以同样修改database等配置, 一般不是很复杂的开发时候, 没有必要这么做, 也可以将database.php放置在conf文件夹下, 同样可以生效(因为几乎每个项目都用到database, 出于人性化考虑, thinkPHP提供这样的功能, 但其他配置名称未必可以这么做了), 这些单独建立的配置文件的优先级高于config.php文件中的配置, 所以会覆盖其中的配置.</p><h1 id="场景配置"><a href="#场景配置" class="headerlink" title="场景配置"></a>场景配置</h1><p>不同场景下使用的配置, 如家里和公司的配置文件<br>在conf/config.php中加上一个配置: ‘app_status’ =&gt; ‘home’<br>然后在conf文件夹之下建立一个文件home.php, 里面设置在家时使用的配置, 比如数据库密码不同, 但注意<strong>数据库</strong>需要设置<strong>全部的配置</strong>, 否则数据库配置会不全(thinkphp一个bug). 同样, 可以建立office.php, 里面设置在办公室时候的配置. 之后如果需要切换, 只需要将app_status修改为home或者office即可</p><h1 id="模块配置"><a href="#模块配置" class="headerlink" title="模块配置"></a>模块配置</h1><p>之前的配置是对所有模块都会生效. 如果想某配置只对某模块起作用该怎么办? 在conf文件夹下建立模块同名的文件夹如index/, 其下新建config.php, 里面设置的配置只对index这个模块生效. 此外, 你也可以再建立文件conf/index/extra/demo.php, 里面设置一些拓展配置, 同样该配置只对index模块起作用.</p><h1 id="动态配置"><a href="#动态配置" class="headerlink" title="动态配置"></a>动态配置</h1><p>主要对当前控制器或者当前方法设置配置. 比如在index控制器中写入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace app\index\controller;</span><br><span class="line"></span><br><span class="line">class index&#123;</span><br><span class="line">  public function __construction()</span><br><span class="line">  &#123;</span><br><span class="line">    config(&apos;before&apos;, &apos;beforeAction&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public function index()</span><br><span class="line">  &#123;</span><br><span class="line">    config(&apos;indexActionn&apos;, &apos;index&apos;);</span><br><span class="line">    dump(config()); // 打印所有配置</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public function demo()</span><br><span class="line">  &#123;</span><br><span class="line">    dump(config());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong> __construction() </strong> 会在执行所有方法之前执行, 打开浏览器输入<br><a href="http://localhost/ThinkPHP/public/index/Index/index" target="_blank" rel="noopener">http://localhost/ThinkPHP/public/index/Index/index</a>  和<br><a href="http://localhost/ThinkPHP/public/index/Index/demo" target="_blank" rel="noopener">http://localhost/ThinkPHP/public/index/Index/demo</a><br>即可查看两种方法下config的区别.</p><h1 id="config类和助手函数config"><a href="#config类和助手函数config" class="headerlink" title="config类和助手函数config"></a>config类和助手函数config</h1><p>config函数可以看做是config类的一个简化, 使用它的时候比较简单比如不需要设置namespace等. Index控制器中输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace app\index\controller;</span><br><span class="line"></span><br><span class="line">use think\Config;</span><br><span class="line"></span><br><span class="line">class Index</span><br><span class="line">&#123;</span><br><span class="line">  public function index()</span><br><span class="line">  &#123;</span><br><span class="line">    // get param</span><br><span class="line">    // $res = Config::get(); // same result as below</span><br><span class="line">    // $res = config();</span><br><span class="line"></span><br><span class="line">    // $res = Config::get(&apos;app_namespace&apos;);// get parameter&apos;s value</span><br><span class="line">    // $res = config(&apos;app_namespace&apos;); // same result as above</span><br><span class="line"></span><br><span class="line">    // dump($res);</span><br><span class="line"></span><br><span class="line">    // set params</span><br><span class="line">    // Config::set(&apos;username&apos;, &apos;theo&apos;);</span><br><span class="line">    // config(&apos;username&apos;, &apos;theo&apos;);</span><br><span class="line">    // dump(Config::get(&apos;username&apos;)); // return null if para doesn&apos;t exist</span><br><span class="line"></span><br><span class="line">    // 设置作用域(第三个参数)</span><br><span class="line">    // Config::set(&apos;username&apos;, &apos;theo&apos;, &apos;index&apos;); // get时候同样需要设置作用域</span><br><span class="line">    // config(&apos;username&apos;, &apos;theo&apos;, &apos;index&apos;);</span><br><span class="line">    // dump(Config::get(&apos;username&apos;), &apos;index&apos;);</span><br><span class="line">    // dump(Config::get(&apos;username&apos;)); // return null if para doesn&apos;t exist</span><br><span class="line"></span><br><span class="line">    $res = config(&apos;?username&apos;);</span><br><span class="line">    $res = Config::has(&apos;username&apos;);</span><br><span class="line">    dump($res);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>取消注释看不同的结果. config()定义在thinkphp/helper.php这个文件里. 可自行查看其代码实现</p>]]></content:encoded>
      
      <comments>http://zhizhou.site/2018/08/02/Thinkphp5%E6%95%99%E7%A8%8B%E4%B8%80-%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Machine Learning Notes</title>
      <link>http://zhizhou.site/2018/06/05/Machine-Learning-Tricks/</link>
      <guid>http://zhizhou.site/2018/06/05/Machine-Learning-Tricks/</guid>
      <pubDate>Tue, 05 Jun 2018 09:54:50 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;Preface: Some note collections about machine learning&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Is-it-possible-to-specify-different-batch-si
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>Preface: Some note collections about machine learning</p></blockquote><h3 id="Is-it-possible-to-specify-different-batch-sizes-for-train-and-validation"><a href="#Is-it-possible-to-specify-different-batch-sizes-for-train-and-validation" class="headerlink" title="Is it possible to specify different batch sizes for train and validation?"></a>Is it possible to specify different batch sizes for train and validation?</h3><p>for train data, there are reasons to keep batches relatively small (batch size can effect training results), however for the validation set, using a single reasonably big batch</p><h3 id="Why-mini-batch-size-is-better-than-one-single-“batch”-with-all-training-data"><a href="#Why-mini-batch-size-is-better-than-one-single-“batch”-with-all-training-data" class="headerlink" title="Why mini batch size is better than one single “batch” with all training data?"></a>Why mini batch size is better than one single “batch” with all training data?</h3><p><a href="http://hp.stuhome.net/index.php/2016/09/20/tensorflow_batch_minibatch/" target="_blank" rel="noopener">Answer1</a>:</p><blockquote><p>深度学习的优化算法，说白了就是梯度下降。每次的参数更新有两种方式。</p><p>第一种，遍历全部数据集算一次损失函数，然后算函数对各个参数的梯度，更新梯度。这种方法每更新一次参数都要把数据集里的所有样本都看一遍，计算量开销大，计算速度慢，不支持在线学习，这称为Batch gradient descent，批梯度下降。</p><p>另一种，每看一个数据就算一下损失函数，然后求梯度更新参数，这个称为随机梯度下降，stochastic gradient descent。这个方法速度比较快，但是收敛性能不太好，可能在最优点附近晃来晃去，hit不到最优点。两次参数的更新也有可能互相抵消掉，造成目标函数震荡的比较剧烈。</p><p>为了克服两种方法的缺点，现在一般采用的是一种折中手段，mini-batch gradient decent，小批的梯度下降，这种方法把数据分为若干个批，按批来更新参数，这样，一个批中的一组数据共同决定了本次梯度的方向，下降起来就不容易跑偏，减少了随机性。另一方面因为批的样本数与整个数据集相比小了很多，计算量也不是很大。</p></blockquote><p><a href="https://datascience.stackexchange.com/questions/16807/why-mini-batch-size-is-better-than-one-single-batch-with-all-training-data" target="_blank" rel="noopener">Answer2</a>:</p><blockquote><p>The key advantage of using minibatch as opposed to the full dataset goes back to the fundamental idea of stochastic gradient descent1.</p><p>In batch gradient descent, you compute the gradient over the entire dataset, averaging over potentially a vast amount of information. It takes lots of memory to do that. But the real handicap is the batch gradient trajectory land you in a bad spot (saddle point).</p><p>In pure SGD, on the other hand, you update your parameters by adding (minus sign) the gradient computed on a single instance of the dataset. Since it’s based on one random data point, it’s very noisy and may go off in a direction far from the batch gradient. However, the noisiness is exactly what you want in non-convex optimization, because it helps you escape from saddle points or local minima(Theorem 6 in [2]). The disadvantage is it’s terribly inefficient and you need to loop over the entire dataset many times to find a good solution.</p><p>The minibatch methodology is a compromise that injects enough noise to each gradient update, while achieving a relative speedy convergence.</p><p>1 Bottou, L. (2010). Large-scale machine learning with stochastic gradient descent. In Proceedings of COMPSTAT’2010 (pp. 177-186). Physica-Verlag HD.</p><p>[2] Ge, R., Huang, F., Jin, C., &amp; Yuan, Y. (2015, June). Escaping From Saddle Points-Online Stochastic Gradient for Tensor Decomposition. In COLT (pp. 797-842).</p></blockquote><h3 id="Train-loss-为-nan-的可能原因"><a href="#Train-loss-为-nan-的可能原因" class="headerlink" title="Train loss 为 nan　的可能原因"></a>Train loss 为 nan　的可能原因</h3><ul><li>learning rate太大，导致loss无法converge而趋近无穷</li><li>检查计算过程是否有除以0的情况</li><li>input data含有nan情况，使用 assert not np.any(np.isnan(x))确保不含有nan情况，同时也保证output data全为有效数据</li></ul><h3 id="神经网络的预测值为常数，不符合实际情况"><a href="#神经网络的预测值为常数，不符合实际情况" class="headerlink" title="神经网络的预测值为常数，不符合实际情况"></a>神经网络的预测值为常数，不符合实际情况</h3><ul><li>神经元麻木，检查是否是因为没有batch normalization</li></ul><h3 id="RNN神经网络添加batch-normalization"><a href="#RNN神经网络添加batch-normalization" class="headerlink" title="RNN神经网络添加batch normalization?"></a>RNN神经网络添加batch normalization?</h3><h3 id="防止过拟合"><a href="#防止过拟合" class="headerlink" title="防止过拟合"></a>防止过拟合</h3><ul><li>修改合适的weight_decay</li><li>减小学习速度</li><li>增加数据</li></ul>]]></content:encoded>
      
      <comments>http://zhizhou.site/2018/06/05/Machine-Learning-Tricks/#disqus_thread</comments>
    </item>
    
    <item>
      <title>编程笔记</title>
      <link>http://zhizhou.site/2018/06/04/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</link>
      <guid>http://zhizhou.site/2018/06/04/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</guid>
      <pubDate>Sun, 03 Jun 2018 22:37:42 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;前言：该文章用于记录个人平时的阅读笔记或者编程随想。内容比较片段化，有些地方略过，有些地方会直接引用，不会细讲，目的只是一个reminder。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;C-智能指针&quot;&gt;&lt;a href=&quot;#C-智能指针&quot; 
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>前言：该文章用于记录个人平时的阅读笔记或者编程随想。内容比较片段化，有些地方略过，有些地方会直接引用，不会细讲，目的只是一个reminder。</p></blockquote><h3 id="C-智能指针"><a href="#C-智能指针" class="headerlink" title="C++ 智能指针"></a>C++ 智能指针</h3><p>C++ 智能指针能够自动释放指针指向的内存，避免内存泄露的危险。常用的C++智能指针有shared_ptr，auto_ptr，unique_ptr和weak_ptr。</p><h4 id="常见的内存错误"><a href="#常见的内存错误" class="headerlink" title="常见的内存错误"></a>常见的内存错误</h4><p>１．内存分配不成功却使用了它。并不是所有内存分配都会成功，在使用之前使用assert(p!=NULL)来检查指针是否为NULL。如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。<br>２．内存分配成功却忘记初始化而直接使用。由于没有初始化指针会乱指导致产生野指针。在变量声明时就可以直接初始化或者指向NULL。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char *p = NULL;</span><br><span class="line">char *str = (char *) malloc(100);</span><br></pre></td></tr></table></figure></p><p>３．内存分配和初始化成功，但操作内存越界、尤其是在使用for循环时，容易混淆下标的范围。<br>４．忘记释放内存，造成内存泄露。如果不是使用智能指针，一个new对应一个delete（malloc与free相同），切记切记！<br>５．多次释放同一个内存。<br>６．使用free或delete释放了内存后，没有将指针指向NULL。导致产生“野指针”。<br>７．已经释放内存了却还使用它。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><h5 id="内容修改和比较"><a href="#内容修改和比较" class="headerlink" title="内容修改和比较"></a>内容修改和比较</h5><p>常量字符串不能修改。虽然从语法上看没有错误，编译器不能发现错误，但是在运行时会出错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char a[] = “hello”;</span><br><span class="line">a[0] = ‘X’;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">char *p = “world”; // 注意p指向常量字符串</span><br><span class="line">p[0] = ‘X’;        // 编译器不能发现该错误</span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p><p>数组不能直接进行复制和比较。将数组a内容复制给b不能简单使用b = a，否则产生编译错误，应该使用strcpy。同理使用strcmp比较两个数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 数组…</span><br><span class="line">char a[] = &quot;hello&quot;;</span><br><span class="line">char b[10];</span><br><span class="line">strcpy(b, a); // 不能用 b = a;</span><br><span class="line">if(strcmp(b, a) == 0) // 不能用 if (b == a)</span><br><span class="line">…</span><br><span class="line">// 指针…</span><br><span class="line">int len = strlen(a);</span><br><span class="line">char *p = (char *)malloc(sizeof(char)*(len+1));</span><br><span class="line">strcpy(p,a); // 不要用 p = a;</span><br><span class="line">if(strcmp(p, a) == 0) // 不要用 if (p == a)</span><br></pre></td></tr></table></figure></p><p>注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。如下示例中，不论数组a的容量是多少，sizeof(a)始终等于sizeof(char *)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void Func(char a[100])</span><br><span class="line">&#123;</span><br><span class="line">　cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4字节而不是100字节</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="指针参数的传递"><a href="#指针参数的传递" class="headerlink" title="指针参数的传递"></a>指针参数的传递</h5><p>不要使用指针去申请动态内存。下例中str最后还是NULL。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void GetMemory(char *p, int num)</span><br><span class="line">&#123;</span><br><span class="line">　p = (char *)malloc(sizeof(char) * num);</span><br><span class="line">&#125;</span><br><span class="line">void Test(void)</span><br><span class="line">&#123;</span><br><span class="line">　char *str = NULL;</span><br><span class="line">　GetMemory(str, 100);  // str 仍然为 NULL</span><br><span class="line">　strcpy(str, &quot;hello&quot;); // 运行错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>毛病出在函数GetMemory中。编译器总是要为函数的每个参数制作临时副本，指针参数p的副本是 _p，编译器使 _p = p。如果函数体内的程序修改了_p的内容，就导致参数p的内容作相应的修改。这就是指针可以用作输出参数的原因。在本例中，_p申请了新的内存，只是把_p所指的内存地址改变了，但是p丝毫未变。所以函数GetMemory并不能输出任何东西。事实上，每执行一次GetMemory就会泄露一块内存，因为没有用free释放内存。</p><p>如果非得要用指针参数去申请内存，那么应该改用“指向指针的指针”，见示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void GetMemory2(char **p, int num)</span><br><span class="line">&#123;</span><br><span class="line">　*p = (char *)malloc(sizeof(char) * num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Test2(void)</span><br><span class="line">&#123;</span><br><span class="line">　char *str = NULL;</span><br><span class="line">　GetMemory2(&amp;str, 100); // 注意参数是 &amp;str，而不是str</span><br><span class="line">　strcpy(str, &quot;hello&quot;);</span><br><span class="line">　cout&lt;&lt; str &lt;&lt; endl;</span><br><span class="line">　free(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于“指向指针的指针”这个概念不容易理解，我们可以用函数返回值来传递动态内存。这种方法更加简单，见示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">char *GetMemory3(int num)</span><br><span class="line">&#123;</span><br><span class="line">　char *p = (char *)malloc(sizeof(char) * num);</span><br><span class="line">　return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Test3(void)</span><br><span class="line">&#123;</span><br><span class="line">　char *str = NULL;</span><br><span class="line">　str = GetMemory3(100);</span><br><span class="line">　strcpy(str, &quot;hello&quot;);</span><br><span class="line">　cout&lt;&lt; str &lt;&lt; endl;</span><br><span class="line">　free(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用函数返回值来传递动态内存这种方法虽然好用，但是常常有人把return语句用错了。这里强调不要用return语句返回指向“栈内存”的指针，因为该内存在函数结束时自动消亡，见示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">char *GetString(void)</span><br><span class="line">&#123;</span><br><span class="line">　char p[] = &quot;hello world&quot;;</span><br><span class="line">　return p;          // 编译器将提出警告</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Test4(void)</span><br><span class="line">&#123;</span><br><span class="line">　char *str = NULL;</span><br><span class="line">　str = GetString(); // str 的内容是垃圾</span><br><span class="line">　cout&lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用调试器逐步跟踪Test4，发现执行str = GetString语句后str不再是NULL指针，但是str的内容不是“hello world”而是垃圾。</p><p>如果把上述示例改写成如下示例，会怎么样？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char *GetString2(void)</span><br><span class="line">&#123;</span><br><span class="line">　char *p = &quot;hello world&quot;;</span><br><span class="line">　return p;</span><br><span class="line">&#125;</span><br><span class="line">void Test5(void)</span><br><span class="line">&#123;</span><br><span class="line">　char *str = NULL;</span><br><span class="line">　str = GetString2();</span><br><span class="line">　cout&lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数Test5运行虽然不会出错，但是函数GetString2的设计概念却是错误的。因为GetString2内的“hello world”是常量字符串，位于静态存储区，它在程序生命期内恒定不变。无论什么时候调用GetString2，它返回的始终是同一个“只读”的内存块。</p><h4 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h4><ul><li><a href="https://www.cnblogs.com/lanxuezaipiao/p/4132096.html" target="_blank" rel="noopener">C++智能指针简单剖析</a></li><li><a href="https://www.cnblogs.com/dragon2012/p/3847966.html" target="_blank" rel="noopener">C++内存池</a></li></ul>]]></content:encoded>
      
      <comments>http://zhizhou.site/2018/06/04/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
